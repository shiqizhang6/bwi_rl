/*
File: OutputDT.cpp
Author: Samuel Barrett
Description: outputs information for the decision tree
Created:  2011-10-26
Modified: 2011-12-10
*/

#include "OutputDT.h"
#include <boost/lexical_cast.hpp>
#include <rl_pursuit/factory/AgentFactory.h>
#include <algorithm>

//OutputDT::FeatureType::FeatureType(const std::string &name, int numCategories):
  //name(name),
  //numCategories(numCategories)
//{
//}

OutputDT::OutputDT(const std::string &filename, const Point2D &dims, unsigned int numPredators, const std::vector<std::string> &modelNames, bool outputArff, bool useDesiredActions, unsigned int numSamples):
  out(filename.c_str()),
  dims(dims),
  numPredators(numPredators),
  outputArff(outputArff),
  useDesiredActions(useDesiredActions),
  featureExtractor(dims),
  numSamples(numSamples)
{
  for (unsigned int i = 0; i < modelNames.size(); i++)
    featureExtractor.addFeatureAgent(modelNames[i],modelNames[i]);
/*
  featureTypes.push_back(FeatureType("Trial",0));
  featureTypes.push_back(FeatureType("Step",0));
  featureTypes.push_back(FeatureType("PredInd",numPredators));
  // relative positions of the agents
  featureTypes.push_back(FeatureType("Prey.dx",0));
  featureTypes.push_back(FeatureType("Prey.dy",0));
  for (unsigned int i = 0; i < numPredators; i++) {
    std::string pred = "Pred" + boost::lexical_cast<std::string>(i);
    featureTypes.push_back(FeatureType(pred + ".dx",0));
    featureTypes.push_back(FeatureType(pred + ".dy",0));
  }
  // some derived features
  for (unsigned int a = 0; a < Action::NUM_NEIGHBORS; a++) {
    std::string name = "Occupied." + boost::lexical_cast<std::string>(a);
    featureTypes.push_back(FeatureType(name,2));
  }
  featureTypes.push_back(FeatureType("NextToPrey",2));
  // most likely actions predicted by the models
  for (unsigned int i = 0; i < modelNames.size(); i++)
    featureTypes.push_back(FeatureType(modelNames[i]+".des",Action::NUM_ACTIONS));
  // history features
  if (FeatureExtractor::USE_ALL_AGENTS_HISTORY) {
    for (unsigned int agentInd = 0; agentInd < numPredators + 1; agentInd++) {
      for (unsigned int j = 0; j < FeatureExtractor::HISTORY_SIZE; j++) {
        std::string key = "HistoricalAction" + boost::lexical_cast<std::string>(agentInd) + "." + boost::lexical_cast<std::string>(j);
        featureTypes.push_back(FeatureType(key,Action::NUM_ACTIONS+1)); // + 1 for when there is no history
      }
    }
  }
  for (unsigned int j = 0; j < FeatureExtractor::HISTORY_SIZE; j++) {
    featureTypes.push_back(FeatureType("MyHistoricalAction." + boost::lexical_cast<std::string>(j),Action::NUM_ACTIONS+1));
  }
  // the true action - NOTE: must be last
  if (useDesiredActions)
    featureTypes.push_back(FeatureType("Pred.des",Action::NUM_ACTIONS));
  else
    featureTypes.push_back(FeatureType("Pred.act",Action::NUM_ACTIONS));
*/
  if (outputArff)
    outputArffHeader();
  else
    outputCSVHeader();
}

void OutputDT::saveStep(unsigned int /*trialNum*/, unsigned int numSteps, const Observation &obs, const std::vector<Action::Type> &desiredActions) {
  assert(obs.preyInd == 0);
  if (useDesiredActions)
    assert(desiredActions.size() == obs.positions.size());

  if (numSteps < 1) {
    histories.clear();
    histories.resize(numPredators);
  } else {
    std::vector<Action::Type> observedActions;
    if (!useDesiredActions) {
      featureExtractor.calcObservedActions(prevObs,obs,observedActions);
    }
    std::vector<std::string> output;
    for (unsigned int predInd = 0; predInd < numPredators; predInd++) {
      unsigned int agentInd = predInd + 1;
      prevObs.myInd = agentInd;
      InstancePtr instancePtr = featureExtractor.extract(prevObs,histories[predInd]);
      Instance &instance = *instancePtr;

      // add the trial number and number of steps
      //instance[FeatureType::Trial] = trialNum;
      //instance[FeatureType::Step] = numSteps - 1;
      
      //assert(instance.size() == featureTypes.size() - 1); // 1 for the true class
      for (unsigned int i = 0; i < FeatureType::NUM - 1; i++) {
        ss << instance[(FeatureType_t)i] << ",";
      }
      if (useDesiredActions) {
        ss << desiredActions[agentInd];
      } else {
        ss << observedActions[agentInd];
      }
      ss << std::endl;
      std::string temp;
      ss >> temp;
      ss.str("");
      //std::cout << "temp: " << temp << "." << std::endl;
      //if (ss.str() != "")
        //std::cout << "ss.str(): " << ss.str() << "." << std::endl;
      assert(ss.str() == "");
      output.push_back(temp);
    }
    outputForSteps.push_back(output);
  }
  prevObs = obs;
}

void OutputDT::outputArffHeader() {
  out << "@relation 'Generated by OutputDT.cpp for a " << dims.x << "x" << dims.y << " world'" << std::endl;
  out << std::endl;
  std::vector<Feature> features;
  FeatureType::getFeatures(features);
  for (unsigned int i = 0; i < FeatureType::NUM; i++) {
    out << "@attribute " << getName((FeatureType_t)i) << " ";
    if (features[i].numeric)
      out << "numeric";
    else {
      out << "{";
      for (unsigned int j = 0; j < features[i].values.size(); j++) {
        out << features[i].values[j];
        if (j != features[i].values.size()-1)
          out << ",";
      }
      out << "}";
    }
    out << std::endl;
  }
  out << std::endl;
  out << "@data" << std::endl;
}

void OutputDT::outputCSVHeader() {
  for (unsigned int i = 0; i < FeatureType::NUM; i++)
    out << getName((FeatureType_t)i) << ",";
  out << std::endl;
}

bool OutputDT::hasCollectedSufficientData() {
  if (numSamples <= 0)
    return false;
  return outputForSteps.size() >= numSamples;
}

void OutputDT::finalizeSave(unsigned int randomSeed) {
  std::vector<unsigned int> inds(outputForSteps.size());
  selectInds(randomSeed,inds);
  
  if (inds.size() < numSamples)
    std::cerr << "OutputDT::finalizeSave: WARNING: not enough data, wanted " << numSamples << " but only got " << inds.size() << std::endl;

  for (unsigned int i = 0; i < inds.size(); i++) {
    unsigned int ind = inds[i];
    for (unsigned int j = 0; j < outputForSteps[ind].size(); j++) {
      out << outputForSteps[ind][j] << std::endl;
    }
  }
}

void OutputDT::selectInds(unsigned int randomSeed, std::vector<unsigned int> &inds) {
  RNG rng(randomSeed);
  rng.randomOrdering(inds);
  if ((numSamples > 0) && (inds.size() > numSamples))
    inds.resize(numSamples);
  std::sort(inds.begin(),inds.end());
}
