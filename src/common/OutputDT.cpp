/*
File: OutputDT.cpp
Author: Samuel Barrett
Description: outputs information for the decision tree
Created:  2011-10-26
Modified: 2011-10-26
*/

#include "OutputDT.h"
#include <boost/lexical_cast.hpp>
#include <factory/AgentFactory.h>
#include <algorithm>

OutputDT::FeatureType::FeatureType(const std::string &name, int numCategories):
  name(name),
  numCategories(numCategories)
{
}

OutputDT::OutputDT(const std::string &filename, const Point2D &dims, unsigned int numPredators, const std::vector<std::string> &modelNames, bool outputArff, bool useDesiredActions, unsigned int numSamples):
  out(filename.c_str()),
  dims(dims),
  numPredators(numPredators),
  outputArff(outputArff),
  useDesiredActions(useDesiredActions),
  featureExtractor(dims),
  numSamples(numSamples)
{
  for (unsigned int i = 0; i < modelNames.size(); i++)
    featureExtractor.addFeatureAgent(modelNames[i],modelNames[i]);

  featureTypes.push_back(FeatureType("Trial",0));
  featureTypes.push_back(FeatureType("Step",0));
  featureTypes.push_back(FeatureType("PredInd",numPredators));
  // relative positions of the agents
  featureTypes.push_back(FeatureType("Prey.dx",0));
  featureTypes.push_back(FeatureType("Prey.dy",0));
  for (unsigned int i = 0; i < numPredators; i++){
    std::string pred = "Pred" + boost::lexical_cast<std::string>(i);
    featureTypes.push_back(FeatureType(pred + ".dx",0));
    featureTypes.push_back(FeatureType(pred + ".dy",0));
  }
  // some derived features
  for (unsigned int a = 0; a < Action::NUM_NEIGHBORS; a++) {
    std::string name = "Occupied." + boost::lexical_cast<std::string>(a);
    featureTypes.push_back(FeatureType(name,2));
  }
  featureTypes.push_back(FeatureType("NextToPrey",2));
  // most likely actions predicted by the models
  for (unsigned int i = 0; i < modelNames.size(); i++)
    featureTypes.push_back(FeatureType(modelNames[i]+".des",Action::NUM_ACTIONS));
  // the true action
  if (useDesiredActions)
    featureTypes.push_back(FeatureType("Pred.des",Action::NUM_ACTIONS));
  else
    featureTypes.push_back(FeatureType("Pred.act",Action::NUM_ACTIONS));

  if (outputArff)
    outputArffHeader();
  else
    outputCSVHeader();
}

void OutputDT::saveStep(unsigned int trialNum, unsigned int numSteps, const Observation &obs, const std::vector<Action::Type> &desiredActions) {
  assert(obs.preyInd == 0);
  if (useDesiredActions)
    assert(desiredActions.size() == obs.positions.size());
  if (numSteps > 1) {
    std::vector<std::string> output;
    for (unsigned int predInd = 0; predInd < numPredators; predInd++) {
      unsigned int agentInd = predInd + 1;
      prevObs.myInd = agentInd;
      Features features;
      featureExtractor.extract(prevObs,features);

      // add the trial number and number of steps
      features["Trial"] = trialNum;
      features["Step"] = numSteps - 1;
      
      assert(features.size() == featureTypes.size() - 1); // 1 for the true class
      for (unsigned int i = 0; i < featureTypes.size() - 1; i++) {
        ss << features[featureTypes[i].name] << ",";
      }
      if (useDesiredActions) {
        ss << desiredActions[agentInd];
      } else {
        // the true action taken
        Point2D diff = getDifferenceToPoint(dims,prevObs.positions[agentInd],obs.positions[agentInd]);
        Action::Type action = getAction(diff);
        ss << action;
      }
      ss << std::endl;
      std::string temp;
      ss >> temp;
      ss.str("");
      //std::cout << "temp: " << temp << "." << std::endl;
      //if (ss.str() != "")
        //std::cout << "ss.str(): " << ss.str() << "." << std::endl;
      assert(ss.str() == "");
      output.push_back(temp);
    }
    outputForSteps.push_back(output);
  }
  prevObs = obs;
}

void OutputDT::outputArffHeader() {
  out << "@relation 'Generated by OutputDT.cpp for a " << dims.x << "x" << dims.y << " world'" << std::endl;
  out << std::endl;
  for (unsigned int i = 0; i < featureTypes.size(); i++) {
    out << "@attribute " << featureTypes[i].name << " ";
    if (featureTypes[i].numCategories == 0)
      out << "numeric";
    else {
      out << "{";
      for (int j = 0; j < featureTypes[i].numCategories; j++) {
        out << j;
        if (j != featureTypes[i].numCategories-1)
          out << ",";
      }
      out << "}";
    }
    out << std::endl;
  }
  out << std::endl;
  out << "@data" << std::endl;
}

void OutputDT::outputCSVHeader() {
  for (unsigned int i = 0; i < featureTypes.size(); i++)
    out << featureTypes[i].name << ",";
  out << std::endl;
}

bool OutputDT::hasCollectedSufficientData() {
  if (numSamples <= 0)
    return false;
  return outputForSteps.size() >= numSamples;
}

void OutputDT::finalizeSave(unsigned int randomSeed) {
  std::vector<unsigned int> inds(outputForSteps.size());
  selectInds(randomSeed,inds);
  
  if (inds.size() < numSamples)
    std::cerr << "OutputDT::finalizeSave: WARNING: not enough data, wanted " << numSamples << " but only got " << inds.size() << std::endl;

  for (unsigned int i = 0; i < inds.size(); i++) {
    unsigned int ind = inds[i];
    for (unsigned int j = 0; j < outputForSteps[ind].size(); j++) {
      out << outputForSteps[ind][j] << std::endl;
    }
  }
}

void OutputDT::selectInds(unsigned int randomSeed, std::vector<unsigned int> &inds) {
  RNG rng(randomSeed);
  rng.randomOrdering(inds);
  if ((numSamples > 0) && (inds.size() > numSamples))
    inds.resize(numSamples);
  std::sort(inds.begin(),inds.end());
}
