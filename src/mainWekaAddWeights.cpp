#include <common/WekaParser.h>
#include <common/DecisionTree.h>
#include <fstream>
#include <string>
#include <iostream>

void readArffHeader(std::ifstream &in, std::vector<std::string> &featureNames, std::vector<bool> &numeric);
void addDataToTree(boost::shared_ptr<DecisionTree> dt, std::ifstream &in, std::vector<std::string> &featureNames, std::vector<bool> &numeric, Features &valueMap);

int main(int argc, const char *argv[]) {
  // handle the command line arguments
  std::string usage = "Usage: wekaAddWeights wekaFile arffFile\n  wekaFile is a tree generated by weka\n  arffFile is a file containing the training data in weka's format";
  if (argc != 3) {
    std::cout << usage << std::endl;
    return 1;
  }
  std::string wekaFile = argv[1];
  std::string arffFile = argv[2];
  
  // read in the original tree
  WekaParser parser(wekaFile,5,false);
  boost::shared_ptr<DecisionTree> dt = parser.makeDecisionTree();

  // open the arffFile and set up some variables
  std::ifstream in(arffFile.c_str());
  assert(in.good());
  std::vector<std::string> featureNames;
  std::vector<bool> numeric;
  Features valueMap;
  valueMap["U"] = Action::UP;
  valueMap["D"] = Action::DOWN;
  valueMap["L"] = Action::LEFT;
  valueMap["R"] = Action::RIGHT;
  valueMap["S"] = Action::NOOP;

  // read in the header
  readArffHeader(in,featureNames,numeric);
  // add data to tree
  addDataToTree(dt,in,featureNames,numeric,valueMap);
  
  in.close();
  std::cout << dt->root;
  
  return 0;
}

void readArffHeader(std::ifstream &in, std::vector<std::string> &featureNames, std::vector<bool> &numeric) {
  std::string str;
  std::string start = "@attribute ";
  int startInd;
  int endInd;

  // read until the attributes
  while (true) {
    std::getline(in,str);
    if (str.compare(0,start.size(),start) != 0)
      continue;
    break;
  }
  // read in the attributes
  while (true) {
    if (str.compare(0,start.size(),start) != 0)
      break;

    startInd = str.find(" ",start.size()-1);
    endInd = str.find(" ",startInd+1);
    featureNames.push_back(str.substr(startInd+1,endInd-startInd-1));
    numeric.push_back(str.substr(endInd+1) == "numeric");
    std::getline(in,str);
  }
  // read until the data
  while (str != "@data")
    std::getline(in,str);
}

void addDataToTree(boost::shared_ptr<DecisionTree> dt, std::ifstream &in, std::vector<std::string> &featureNames, std::vector<bool> &numeric, Features &valueMap) {
  Features features;
  float val;
  std::string val2;
  Classification c;
  //int count = 10;
  while (!in.eof()) {
    for (unsigned int i = 0; i < featureNames.size(); i++) {
      if (numeric[i]) {
        in >> val;
        in.ignore(1,',');
      } else {
        //std::cout << ((char)in.get()) << std::endl;
        std::getline(in,val2,',');
        val = valueMap[val2];
        //std::cout << val2 << std::endl;
      }
      features[featureNames[i]] = val;
      //std::cout << featureNames[i] << " " << val << " " << (featureNames[i] == "Pred.act") << std::endl;
    }

    features["Next2Prey?"] = features["Next2Prey"];
    features["Greedy"] = features["Greedy.des"];
    features["Team Aware"] = features["TA.des"];
    features["Greedy Prob"] = features["GP.des"];
    features["Prob Dest"] = features["PD.des"];
    features["DeltaXtoP"] = features["DeltaXToPrey"];
    features["DeltaYtoP"] = features["DeltaYToPrey"];
    features["sum"] = 0; // TODO
  
    unsigned int trueClass = (int)(features[featureNames.back()] + 0.5);
    dt->classify(features,c,true,trueClass);
  }
}
